page.title=Intents List: NFC and NDEF Intents
sdk.redirect=0

@jd:body


<div id="qv-wrapper">
<div id="qv">
<h2>In this document</h2>
<ol>
<li><a href="#lowlevelintents">Low level intents</a>
<ol>
<li><a href="#userfeedback">User feedback</a></li>
<li><a href="#tagread">Tag read</a></li>
<li><a href="#targetdiscovered">Target detected</a></li>
</ol>
<li><a href="#highlevel">NDEF intents</a></li>
<li><a href="#cardtransaction">Card emulation events</a></li>
</li>

<h2>Key classes</h2>
<ol>
<li>{@link android.nfc.NfcService}</li>
<li>{@link android.nfc.NDEFMessage}</li>
</ol>

<h2>See also</h2>
<a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>.
</div>
</div>


Tag reading and other target discovery is handled in the NFC stack, which then generates a number of events
depending on the target type and the stack capability to read them. Some events are also provided to improve
user experience, allowing some form of feedback (haptics, icon) when the NFC field is entered and left.

<p>
The primary use case is the reading of 
NDEF-formated message on NFC Forum type tags. This should generate high level intents that 
activities can register upon to handle the NDEF messages.

<p>However, when an application relies upon a specific message format (other than NDEF), or on a specific 
technology (other than NFC Forum type tags), or a specific set of cryptographic keys (in a Mifare classic
type of card), it is still possible to register for tag detection events. In the former case, the entire 
tag will be read by the stack and provided as a raw array of bytes, in the latter cases, the application 
will be in charge of interacting with the target using the adequate method calls.

<p>
This variety of use cases is summarised in the figure below : 
<p>
<a href="doc-files/Tags_intents.png"><img src="doc-files/Tags_intents.png" width=800></a>

<h2 id="lowlevelintents">Low level broadcast intents</h2>


<h3 id="userfeedback"> User feedback intents </h3>

These intents are generated by the NFC stack to allow some user feedback (haptics, sound, notifications) to be 
made to the user by higher layers.

<table> <tr> <th scope="col">Type</th>
          <th scope="col">Action</th>
          <th scope="col">Mime type</th>
          <th scope="col">Intent URI</th>
          <th scope="col">Extras</th>
	</tr>
	<tr> <td>Broadcast</td>
	<td>android.nfc.ACTION_NFC_FIELD_EVENT</td>
	<td>-</td>
	<td>-</td>
	<td>int "event" : contains indication that a tag is being read or that reading has ended<ul><li>NFC_TAG_DETECTED<li>NFC_FIELD_OFF</ul></td>
</tr></table>

<h3 id="tagread">Tag successfully read intent</h3>

When the NFC stack was able to access successfully the entire tag contents, regardless of its technology, this
event is generated. In case a tag has a specific access technology (e.g. Mifare with specific keys), the ACTION_TARGET_DISCOVERED event is generated instead. 

This intent is an ordered broadcast type of event. It should be primarily handled in the NDEF service, which handles the primary use case of NDEF tags. If the tag is not found to contain an NDEF message, it can be parsed by other receivers to check for proprietary data formats.

<table> <tr> <th scope="col">Type</th>
          <th scope="col">Action</th>
          <th scope="col">Mime type</th>
          <th scope="col">Intent URI</th>
          <th scope="col">Extras</th>
	</tr>
	<tr> <td>Broadcast (ordered)</td>
	<td>android.nfc.ACTION_TAG_READ</td>
	<td>-</td>
	<td>-</td>
	<td>byte [] "data" : whole tag binary contents.</td>
</tr></table>

<h3 id="targetdiscovered">Target discovered message</h3>

When an NFC target was discovered that could not be entirely read by the NFC stack (because it has specific access keys or because it is an ISO 14443-4 contactless card), the following event is generated : 


<table> <tr> <th scope="col">Type</th>
          <th scope="col">Action</th>
          <th scope="col">Mime type</th>
          <th scope="col">Intent URI</th>
          <th scope="col">Extras</th>
	</tr>
	<tr> <td>Broadcast (ordered)</td>
	<td>android.nfc.ACTION_TARGET_DISCOVERED</td>
	<td>-</td>
	<td>nfc:/<i>&lt;technology&gt;</i>/<i>&lt;identifier&gt;</i>
<p>	where <i>&lt;technology&gt;</i> reflects the target access technology : <ul><li>"ISO1443-4" <li>"Mifare_UL"<li>"Picopass"<li>etc...</ul> and <i>&lt;identifier&gt;</i> will depend upon the technology (e.g. UID for an ISO contactless card).
</td>
	<td>String "technology" : same as in URI <p>String "identifier" : same as in URI</td>
</tr></table>

Once registered for a particular technology type, the client applications can then examine each event and decide to handle the target or not. 

<h2 id="highlevel">NDEF message intents</h2>
<p>

  <table>
      <tr>
          <th scope="col">Intent Action</th>
          <th scope="col">Mime type</th>
          <th scope="col">Intent URI</th>
          <th scope="col">Description</th>
      </tr>
      <tr>
      	  <td rowspan="4">DEFAULT<br/>(android.intent.ACTION_VIEW)</d>
      	  <td rowspan="4">message/x-ndef</td>
      	  <td>ndef://rtd/<em>urn</em>/<em>subpath</em></td>
          <td>for RTD tags</td>
      </tr>
      <tr>
      	  <td>ndef://mime/<em>mimetype</em></td>
          <td>for MIME tags</td>
      </tr>
      <tr>
      	  <td>ndef://rtd_external/<em>external type URN</em></td>
          <td>for external RTDs</td>
      </tr>
      <tr>
      	  <td>ndef://uri/<em>uri</em></td>
          <td>for types named by URIs</td>
      </tr>
  </table>

  <table>
	<tr>
		<th>Extra field</th>
		<th>Type</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>NdefMessage.EXTRA_NDEF<br/>("org.opennfc.intent.EXTRA_NDEF")</td>
		<td>byte array</td>
		<td>Raw bytes of NDEF message</td>
	</tr>
  </table>

<p>Some example URIs:</p>
<ul>
 <li>ndef://rtd/urn:nfc:wkt:Sp/tel:+71234567</li>
 <li>ndef://rtd/urn:nfc:wkt:U/tel+71234567</li>
 <li>ndef://rtd/urn:nfc:wkt:Gc/</li>
 <li>ndef://mime/text/v-card</li>
 <li>ndef://rtd_external/urn:nfc:ext:nokia.com:bt</li>
</ul>


  
<h2 id="cardtransaction">Card emulation events</h2>

When the NFC handset performs card emulation through SWP/HCI with the SIM card or another secure element, there
is a way for the targeted card application to wake up its companion phone application through a push message.
<p>
This event will be reported into the system by the NFC stack with the following intent : 


<table> <tr> <th scope="col">Type</th>
          <th scope="col">Action</th>
          <th scope="col">Mime type</th>
          <th scope="col">Intent URI</th>
          <th scope="col">Extras</th>
	</tr>
	<tr> <td>Uni</td>
	<td>android.nfc.ACTION_SE_PUSH</td>
	<td>-</td>
	<td>nfc:/secure_element:<i>&lt;se_id&gt;</i>/<i>&lt;AID&gt;</i><p>where <i>&lt;se_id&gt;</i> identifies the secure element originating the push request <p><i>&lt;AID&gt;</i> identifies the application that triggered the push</td>
	<td><ul><li>byte [] "AID" : AID of the card application<li>byte [] "extra" : extra data in the HCI event</td>
</tr></table>

